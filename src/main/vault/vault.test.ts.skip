
import { describe, it, expect, vi, beforeAll, afterAll } from 'vitest';
import * as path from 'path';
import * as fs from 'fs';

const TEST_DIR = path.resolve(__dirname, 'test_vault_data');

vi.mock('electron', () => ({
    app: {
        getPath: (name: string) => {
            if (name === 'userData') return TEST_DIR;
            return TEST_DIR;
        },
        isPackaged: false
    },
}));

vi.mock('os', () => ({
    homedir: () => TEST_DIR,
    platform: () => 'linux',
    tmpdir: () => '/tmp',
    release: () => '1.0.0',
    type: () => 'Linux',
    endianness: () => 'LE',
    arch: () => 'x64'
}));

describe('Vault Database', () => {
    let initVault: any;
    let getVaultDB: any;

    beforeAll(async () => {
        if (fs.existsSync(TEST_DIR)) {
            fs.rmSync(TEST_DIR, { recursive: true, force: true });
        }
        fs.mkdirSync(TEST_DIR, { recursive: true });

        // Dynamic import to ensure mocks are active and FS is ready
        const dbModule = await import('./db');
        initVault = dbModule.initVault;
        getVaultDB = dbModule.getVaultDB;
    });

    afterAll(() => {
        try {
            const db = getVaultDB();
            db.close();
        } catch { }

        if (fs.existsSync(TEST_DIR)) {
            fs.rmSync(TEST_DIR, { recursive: true, force: true });
        }
    });

    it('should initialize the database and create tables', () => {
        initVault();
        const db = getVaultDB();

        // Check tables exist
        const tables = db.prepare("SELECT name FROM sqlite_master WHERE type='table'").all();
        const tableNames = tables.map((t: any) => t.name);

        expect(tableNames).toContain('documents');
        expect(tableNames).toContain('document_sources');
        expect(tableNames).toContain('chunks');
        expect(tableNames).toContain('ingestion_jobs');
        expect(tableNames).toContain('action_plans');
        expect(tableNames).toContain('actions');
    });

    it('should enforce foreign keys', () => {
        const db = getVaultDB();

        // Try to insert a source without a document
        // We expect this to throw an SqliteError
        expect(() => {
            db.prepare('INSERT INTO document_sources (source_uri, document_id) VALUES (?, ?)').run('file:///test', 'non-existent-id');
        }).toThrow();
    });

    it('should support FTS5 search', () => {
        const db = getVaultDB();

        // Insert a document and chunk
        const docId = 'doc-1';
        try {
            db.prepare('INSERT INTO documents (id, hash, mime_type, size_bytes) VALUES (?, ?, ?, ?)').run(docId, 'hash1', 'text/plain', 100);
        } catch (e) {
            // Ignore if already exists (primary key) from previous tests if running in parallel? 
            // But here tests run sequentially in same file mostly.
        }

        const chunkId = 'chunk-1';
        const content = 'The quick brown fox jumps over the lazy dog';
        db.prepare('INSERT INTO chunks (id, document_id, content, content_hash, chunk_index, start_char_offset, end_char_offset) VALUES (?, ?, ?, ?, ?, ?, ?)').run(chunkId, docId, content, 'hash-content', 0, 0, content.length);

        // Query FTS
        const results = db.prepare('SELECT * FROM chunks_fts WHERE chunks_fts MATCH ?').all('fox');
        expect(results.length).toBe(1);
        expect(results[0].content).toBe(content);
    });
});
